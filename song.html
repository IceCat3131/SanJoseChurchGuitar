
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>è¯—æ­Œ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <link rel="stylesheet" href="style.css" />
  <!-- ç®€ç¹è½¬æ¢åº“ï¼šopencc-jsï¼ˆæµè§ˆå™¨ UMD å®Œæ•´ç‰ˆï¼‰ -->
  <script src="https://cdn.jsdelivr.net/npm/opencc-js@1.0.5/dist/umd/full.js"></script>
</head>
<body>
<div class="page">
  <div class="page-inner">

    <!-- ç¬¬ 1 éƒ¨åˆ†ï¼šè¿”å›é¦–é¡µ / ä¸Šä¸€é¦– / æ ‡é¢˜ / ä¸‹ä¸€é¦– -->
    <div class="topbar">
      <div class="topbar-left">
        <button class="topbar-button" id="btn-back" aria-label="è¿”å›é¦–é¡µ">
  <svg viewBox="0 0 24 24" class="icon-home">
    <path d="M3 10.5 12 3l9 7.5v9.5a1 1 0 0 1-1 1h-5.5v-6h-5v6H4a1 1 0 0 1-1-1v-9.5z"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round" />
  </svg>
</button>
      </div>
      <button class="topbar-button" id="btn-prev" aria-label="ä¸Šä¸€é¦–">&lt;</button>
      <div class="topbar-title" id="song-title">è¯—æ­Œ</div>
      <button class="topbar-button" id="btn-next" aria-label="ä¸‹ä¸€é¦–">&gt;</button>
    </div>

    <!-- ç¬¬ 2 éƒ¨åˆ†ï¼šæœç´¢æ¡† -->
    <div class="card">
      <div class="search-bar">
        <div class="search-book-toggle">
          <button class="search-book-btn" data-book="c" id="btn-book-c">å¤§æœ¬</button>
          <div class="search-book-divider"></div>
          <button class="search-book-btn" data-book="ts" id="btn-book-ts">å°æœ¬</button>
        </div>
        <div class="search-input-wrap">
          <input
            id="search-input"
            class="search-input"
            type="text"
            inputmode="numeric"
            pattern="[0-9]*"
            placeholder="è¾“å…¥ç¼–å·ï¼Œå¦‚31"
          />
          <button class="search-icon-btn" id="btn-search">
            <span class="search-icon">ğŸ”</span>
          </button>
        </div>
      </div>
    </div>

    <!-- ç¬¬ 3 éƒ¨åˆ†ï¼š+ / - / å‰ä»– / æ­Œè¯ / ç®€ç¹ -->
    <div class="controls-row">
      <div class="controls-left">
        <button class="icon-plusminus-btn" id="btn-font-plus">+</button>
        <button class="icon-plusminus-btn" id="btn-font-minus">âˆ’</button>
        <div class="mode-toggle">
          <button class="mode-btn active" id="btn-mode-score">å‰ä»–</button>
          <button class="mode-btn" id="btn-mode-lyrics">æ­Œè¯</button>
        </div>
      </div>
      <!-- ç®€ç¹åˆ‡æ¢æŒ‰é’®ï¼šä¸€ä¸ªå­—ï¼Œé»˜è®¤æ˜¾ç¤ºâ€œç¹â€ï¼ˆå½“å‰æ­Œè¯ä¸ºç®€ä½“ï¼‰ -->
      <button class="script-toggle-btn" id="btn-script">ç¹</button>
    </div>

    <!-- ç¬¬ 4 éƒ¨åˆ†ï¼šå†…å®¹ -->
    <div class="content-card">
      <div id="score-view" class="score-wrap" aria-hidden="false">
        <!-- SVG ä¹è°± -->
      </div>
      <div id="lyrics-view" class="lyrics-root" style="display: none;" aria-hidden="true">
        <!-- æ­Œè¯ -->
      </div>
    </div>

  </div>
</div>

<script>
  const BOOKS = {
    c: {
      label: "å¤§æœ¬è¯—æ­Œ",
      folderText: "c_text",
      svgPrefix: "assets/c/c",
      codePrefix: "c"
    },
    ts: {
      label: "å°æœ¬è¯—æ­Œ",
      folderText: "ts_text",
      svgPrefix: "assets/ts/ts",
      codePrefix: "ts"
    }
  };

  const MAX_RANGES = 20; // æœ€å¤šæ”¯æŒ 2000 é¦–ï¼ˆå¤Ÿç”¨äº†ï¼‰

  const state = {
    currentBook: "c",
    currentNo: 1,
    // â€œæ˜¾ç¤ºæ¨¡å¼â€ï¼šscore=å‰ä»–è°±ï¼Œlyrics=æ­Œè¯
    mode: "score",
    // æ­Œè¯å½“å‰æ˜¾ç¤ºï¼šsimplified=ç®€ä½“, traditional=ç¹ä½“
    script: "simplified",
    lyricsFontSize: 16,
    data: { c: [], ts: [] },
    loadedRanges: { c: {}, ts: {} }
  };

  let converterToTraditional = null; // ç®€ -> ç¹
  let converterToSimplified = null;  // ç¹ -> ç®€

  function setupConvertersIfNeeded() {
    if (!window.OpenCC) return;
    if (!converterToTraditional) {
      // ç®€ä½“ï¼ˆcnï¼‰ -> ç¹ä½“ï¼ˆtwï¼‰
      converterToTraditional = OpenCC.Converter({ from: "cn", to: "tw" });
    }
    if (!converterToSimplified) {
      // ç¹ä½“ï¼ˆtwï¼‰ -> ç®€ä½“ï¼ˆcnï¼‰
      converterToSimplified = OpenCC.Converter({ from: "tw", to: "cn" });
    }
  }

  function convertTextByScript(text) {
    setupConvertersIfNeeded();
    if (state.script === "traditional" && converterToTraditional) {
      return converterToTraditional(text);
    }
    if (state.script === "simplified" && converterToSimplified) {
      return converterToSimplified(text); // å¦‚æœåŸ JSON å°±æ˜¯ç®€ä½“ï¼Œè¿™é‡ŒåŸºæœ¬ç­‰äºåŸæ–‡
    }
    return text;
  }

  function pad4(num) {
    return String(num).padStart(4, "0");
  }

  function parseQuery() {
    const params = new URLSearchParams(window.location.search);
    const book = params.get("book") || "c";
    let no = parseInt(params.get("no") || "1", 10);
    if (!Number.isFinite(no) || no < 1) no = 1;
    state.currentBook = (book === "ts") ? "ts" : "c";
    state.currentNo = no;
  }

  function getRangeIndex(no) {
    return Math.floor((no - 1) / 100); // 1-100 -> 0, 101-200 -> 1 ...
  }

  function getRangeFilePath(bookKey, rangeIndex) {
    const start = rangeIndex * 100 + 1;
    const end = (rangeIndex + 1) * 100;
    const folder = BOOKS[bookKey].folderText;
    return `assets/${folder}/${bookKey}_${start}_${end}.json`;
  }

  async function loadRange(bookKey, rangeIndex) {
    if (state.loadedRanges[bookKey][rangeIndex]) return true;
    const url = getRangeFilePath(bookKey, rangeIndex);
    try {
      const res = await fetch(url);
      if (!res.ok) {
        state.loadedRanges[bookKey][rangeIndex] = true;
        return false;
      }
      const json = await res.json();
      if (!Array.isArray(json) || json.length === 0) {
        state.loadedRanges[bookKey][rangeIndex] = true;
        return false;
      }
      state.data[bookKey] = state.data[bookKey].concat(json);
      state.loadedRanges[bookKey][rangeIndex] = true;
      return true;
    } catch (e) {
      console.error("åŠ è½½åŒºé—´å¤±è´¥", bookKey, rangeIndex, e);
      state.loadedRanges[bookKey][rangeIndex] = true;
      return false;
    }
  }

  async function ensureRangeForNo(bookKey, no) {
    const rangeIndex = getRangeIndex(no);
    return await loadRange(bookKey, rangeIndex);
  }

  function findLocalSong(bookKey, no) {
    const songs = state.data[bookKey] || [];
    return songs.find(s => s.no === no) || null;
  }

  async function getSong(bookKey, no) {
    await ensureRangeForNo(bookKey, no);
    return findLocalSong(bookKey, no);
  }

  function renderScore(bookKey, no) {
    const container = document.getElementById("score-view");
    container.innerHTML = "";
    const folderPrefix = BOOKS[bookKey].svgPrefix;
    const src = `${folderPrefix}${pad4(no)}_cn_g.svg`; // å¦‚ assets/c/c0001_cn_g.svg
    const img = document.createElement("img");
    img.alt = `${BOOKS[bookKey].label} ç¬¬ ${no} é¦– å‰ä»–è°±`;
    img.src = src;
    container.appendChild(img);
  }

  function renderLyrics(song) {
    const root = document.getElementById("lyrics-view");
    root.innerHTML = "";
    if (!song || !song.lyrics) return;

    root.style.fontSize = state.lyricsFontSize + "px";

    song.lyrics.forEach(section => {
      const sec = document.createElement("div");
      sec.className = "lyrics-section";

      const noDiv = document.createElement("div");
      noDiv.className = "lyrics-section-no";
      noDiv.textContent = section.section_no || "";

      const linesWrap = document.createElement("div");
      linesWrap.className = "lyrics-lines";

      (section.lines || []).forEach(lineText => {
        const p = document.createElement("p");
        p.textContent = convertTextByScript(lineText || "");
        linesWrap.appendChild(p);
      });

      sec.appendChild(noDiv);
      sec.appendChild(linesWrap);
      root.appendChild(sec);
    });
  }

  function updateTitle(song) {
    const titleEl = document.getElementById("song-title");
    if (song && song.title) {
      titleEl.textContent = song.title;
      document.title = song.title + " - å¬ä¼šè¯—æ­Œå‰ä»–è°±";
    } else {
      titleEl.textContent = `${BOOKS[state.currentBook].label} ç¬¬ ${state.currentNo} é¦–`;
      document.title = titleEl.textContent;
    }
  }

  function setMode(mode) {
    state.mode = mode;
    const scoreView = document.getElementById("score-view");
    const lyricsView = document.getElementById("lyrics-view");

    const btnScore = document.getElementById("btn-mode-score");
    const btnLyrics = document.getElementById("btn-mode-lyrics");

    if (mode === "score") {
      scoreView.style.display = "";
      scoreView.setAttribute("aria-hidden", "false");
      lyricsView.style.display = "none";
      lyricsView.setAttribute("aria-hidden", "true");
      btnScore.classList.add("active");
      btnLyrics.classList.remove("active");
    } else {
      scoreView.style.display = "none";
      scoreView.setAttribute("aria-hidden", "true");
      lyricsView.style.display = "";
      lyricsView.setAttribute("aria-hidden", "false");
      btnScore.classList.remove("active");
      btnLyrics.classList.add("active");
    }
  }

  function syncBookButtons() {
    document.getElementById("btn-book-c").classList.toggle("active", state.currentBook === "c");
    document.getElementById("btn-book-ts").classList.toggle("active", state.currentBook === "ts");
  }

  function syncScriptButton() {
    const btn = document.getElementById("btn-script");
    // å½“å‰æ­Œè¯æ˜¯ç®€ä½“ -> æŒ‰é’®æ˜¾ç¤ºâ€œç¹â€ï¼›å½“å‰æ­Œè¯ç¹ä½“ -> æŒ‰é’®æ˜¾ç¤ºâ€œç®€â€
    if (state.script === "simplified") {
      btn.textContent = "ç¹";
      btn.classList.remove("active");
    } else {
      btn.textContent = "ç®€";
      btn.classList.add("active");
    }
  }

  function updateURL() {
    const url = new URL(window.location.href);
    url.searchParams.set("book", state.currentBook);
    url.searchParams.set("no", String(state.currentNo));
    window.history.replaceState({}, "", url.toString());
  }

  async function loadAndRenderCurrentSong() {
    const song = await getSong(state.currentBook, state.currentNo);
    if (!song) {
      alert("æ‰¾ä¸åˆ°è¿™é¦–è¯—æ­Œçš„æ­Œè¯æ•°æ®ã€‚");
      return;
    }
    updateTitle(song);
    renderScore(state.currentBook, state.currentNo);
    renderLyrics(song);
    setMode(state.mode); // ä¿æŒå½“å‰ å‰ä»– / æ­Œè¯ æ¨¡å¼
    syncScriptButton();
  }

  async function tryGoTo(delta) {
    const newNo = state.currentNo + delta;
    if (newNo <= 0) {
      alert("å·²ç»æ˜¯ç¬¬ä¸€é¦–äº†ã€‚");
      return;
    }
    const song = await getSong(state.currentBook, newNo);
    if (!song) {
      alert(delta > 0 ? "å·²ç»æ˜¯æœ€åä¸€é¦–äº†ã€‚" : "å·²ç»æ˜¯ç¬¬ä¸€é¦–äº†ã€‚");
      return;
    }
    state.currentNo = newNo;
    updateURL();
    await loadAndRenderCurrentSong();
  }

  function goToNumber(no) {
    state.currentNo = no;
    updateURL();
    loadAndRenderCurrentSong();
  }

  function handleSearch() {
    const raw = document.getElementById("search-input").value.trim();
    if (!raw) return;
    const digitsMatch = raw.match(/(\d{1,4})$/);
    if (!digitsMatch) {
      alert("è¯·è¾“å…¥æ­£ç¡®çš„ç¼–å·ï¼Œå¦‚ 31");
      return;
    }
    const no = parseInt(digitsMatch[1], 10);
    if (!Number.isFinite(no)) {
      alert("è¯·è¾“å…¥æ­£ç¡®çš„ç¼–å·ï¼Œå¦‚ 31");
      return;
    }
    goToNumber(no);
  }

  document.addEventListener("DOMContentLoaded", async () => {
    parseQuery();
    document.getElementById("search-input").value = state.currentNo;  // â˜… æ˜¾ç¤ºå½“å‰ç¼–å·
    syncBookButtons();
    syncScriptButton(); // é»˜è®¤ï¼šæ­Œè¯ç®€ä½“ï¼ŒæŒ‰é’®æ˜¾ç¤ºâ€œç¹â€

    document.getElementById("btn-back").addEventListener("click", () => {
      window.location.href = "index.html";
    });

    document.getElementById("btn-prev").addEventListener("click", () => {
      tryGoTo(-1);
    });

    document.getElementById("btn-next").addEventListener("click", () => {
      tryGoTo(1);
    });

    // å¤§æœ¬ / å°æœ¬åˆ‡æ¢
    document.querySelectorAll(".search-book-btn").forEach(btn => {
      btn.addEventListener("click", async () => {
        const book = btn.dataset.book;
        if (state.currentBook === book) return;
        state.currentBook = book;
        syncBookButtons();
        // åŒç¼–å·è‹¥ä¸å­˜åœ¨ï¼Œä¼šåœ¨ loadAndRenderCurrentSong é‡Œæç¤º
        updateURL();
        await loadAndRenderCurrentSong();
      });
    });

    // æœç´¢
    document.getElementById("btn-search").addEventListener("click", handleSearch);
    document.getElementById("search-input").addEventListener("keydown", e => {
      if (e.key === "Enter") {
        e.preventDefault();
        handleSearch();
      }
    });

    // å‰ä»– / æ­Œè¯æ¨¡å¼
    document.getElementById("btn-mode-score").addEventListener("click", () => {
      setMode("score");
    });
    document.getElementById("btn-mode-lyrics").addEventListener("click", () => {
      setMode("lyrics");
    });

    // ç®€ç¹æŒ‰é’®ï¼šä¸€ä¸ªä½ç½®ï¼Œæ–‡å­—äº’æ¢
    document.getElementById("btn-script").addEventListener("click", () => {
      state.script = (state.script === "simplified") ? "traditional" : "simplified";
      syncScriptButton();
      // é‡æ–°æ¸²æŸ“æ­Œè¯ï¼Œè®©è½¬æ¢ç”Ÿæ•ˆ
      getSong(state.currentBook, state.currentNo).then(song => {
        if (song) renderLyrics(song);
      });
    });

    // å­—å· + / -
    document.getElementById("btn-font-plus").addEventListener("click", () => {
      state.lyricsFontSize = Math.min(state.lyricsFontSize + 3, 40);
      getSong(state.currentBook, state.currentNo).then(song => {
        if (song) renderLyrics(song);
      });
    });
    document.getElementById("btn-font-minus").addEventListener("click", () => {
      state.lyricsFontSize = Math.max(state.lyricsFontSize - 2, 30);
      getSong(state.currentBook, state.currentNo).then(song => {
        if (song) renderLyrics(song);
      });
    });

    await loadAndRenderCurrentSong();
  });
</script>
</body>
</html>
